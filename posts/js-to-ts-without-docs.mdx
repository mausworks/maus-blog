---
title: "JS to TS without leaving your IDE"
description: "The menial task of finding the right type."
createdAt: "2021-09-14T20:00:06.668Z"
banner: "/img/posts/inspect.jpg"
bannerSource: "https://unsplash.com/photos/mQHEgroKw2k"
---

In [my previous post I added custom syntax highlighting to this blog](/custom-syntax-highlighting-in-mdx),
and for that I used the plugin `rehype-shiki` from GitHub user `stefanprobst`.
While this _kinda worked_, it also _kinda didn't_, this could possibly be because of a version mismatch,
between packages, or possibly because of something else, and I don't care enough to find out.

Since the plugin is just one file, I decided to just steal Stefan's code and
try to fix the problem locally with some decent IDE support&mdash;that way
I don't have to dive straight into [dependency hell](https://en.wikipedia.org/wiki/Dependency_hell).

_I know, I know_&mdash;the _right thing_ to do here would be to fix the issue,
and submit a pull request to their repository, but &hellip;

![Ain't nobody got time for that](/gifs/aint-nobody-got-time-for-that.gif)

While I deeply appreciate that Stefan had included type definitions with their code,
I still prefer if all code within my projects is in TypeScript, so I wanted to convert and refactor it!
That's _clearly_ a more worthy investment of my time.

Just like in the previous post&mdash;I'm not quite sure what I'm doing,
_but_&mdash;I can apply the same strategy as I did then in order to figure things out.
This time it will be more of a menial task however,
as the types that are being used also implement a whole bunch of generics from libraries that I have never used.

But before I get into the actual TypeScript conversion,
I'll start with just going through the code and refactor it
because as soon as I started looking at it I noticed that it's definitely not to my taste.
This is also a really good way for me to learn what the code actually does!

## Putting things in the right order

Looking at this part of the code &hellip; where would you assume that `transformer` is defined?

```js
const loadedLanguages = // ...
const ignoreUnknownLanguage = // ...

return transformer;
```

<Poll
  required={true}
  wrongResponse="Nope! Apparently not."
  correctResponse="Yep! You knew this was a trick question, didn't you?"
  options={{
    "Before this function": false,
    "After this function": false,
    "In this function, before the return statement": false,
    "In this function, after the return statement": true,
  }}
/>

Writing code like this is called _[hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)_,
and it has some very good use-cases&mdash;_but this definitely isn't one of them!_

My reasoning for this is simple, because defining something _after_ a return statement looks a whole lot like unreachable code,
and the reader will I have to stop with whatever they are doing to interpret what is actually going on!

I think that hoisting makes sense for when you want to have some helper functions
that handle some _minute implementation details_ in the same file.
But in this case I think that you should put it _at the end of the file_,
and not after a return statement.

I this case I think it is especially unnecessary, because you can just do this instead:

```js
return function transformer(tree) {
  // ...
};
```

&hellip; or if you want to be less explicit:

```js
return (tree) => {
  // ...
};
```

## Handling defaults

Since ES6 (2015) you can use object destructuring,
this feature is _especially_ powerful when you need to handle default values,
because it allows you to take this mess &hellip;

```js
function attacher(options) {
  const highlighter = options.highlighter;
  const loadedLanguages = highlighter.getLoadedLanguages();
  const ignoreUnknownLanguage =
    options.ignoreUnknownLanguage == null
      ? true
      : options.ignoreUnknownLanguage;
}
```

&hellip; and turn it into this:

```js
function attacher({ highlighter, ignoreUnknownLanguages = true }) {
  const loadedLanguages = highlighter.getLoadedLanguages();
}
```

_I love this feature_, because of two reasons:

- It implicitly conveys that this is "a default"
- It cuts down on _a lot_ of boilerplate code

> **Tip:** If you are working with React,
> then this can be incredibly useful for when you want to provide default values to some of your props.

## Squinting at types

Now that I have refactored some of the things that I don't like about this code,
let's get into actually adding some types!

When you're working with just your own code, this is usually often trivial:
Define your interfaces, enums (if you must), union types, et al,
and then slap some types on your function parameters, then you're pretty much good to go!

However, if you are working with libraries that attempt to solve problems in a generic problem space,
then these libraries will often also include at least a few generic types&mdash;and in order to understand these types,
you often have to immerse yourself in the problem space and try to understand it more intimately.

The method of "type glancing" that I used in my previous post _still works_,
but we now need to not only understand a handful of simple type signatures&mdash;we also need get a more holistic
understanding of multiple generic types and how they interplay.
This is not _always_ the case, but in this particular example, it is.

It can sometimes also be hard to even get started, I mean&mdash;what's the type of `tree` in this function?

```js
export function transformer(tree) {
  visit(tree, "element", visitor);

  function visitor(node, _index, parent) {
    // ...
  }
}
```

Yeah&mdash;I don't know either! If it wasn't for the fact that the function was exported,
then I could probably look at its usage and try to figure it out.

Luckily, the `visit` function (called just below) is imported from `unist-util-visit`, and _that_ has types,
so let's look at that &hellip;

```ts
declare const visit: {
  <V extends Node>(
    tree: Node,
    test: Test<V> | Array<Test<any>>,
    visitor: visit.Visitor<V>,
    reverse?: boolean
  ): void;
};
```

![Thinking ...](/gifs/batman-think.gif)

OK, at least we now know that the first `tree` parameter is simply a `Node` but what about the rest?

Let's try to break it down:

1. The `visit` function is generic, and it accepts a single type argument.
1. The type argument has to be of a type which inherits the properties of `Node`.
1. The second argument `Test` also accepts `V` as a type argument.
1. The last argument is the `visitor` function,
   it has to be of the type `Visitor<T>`; but let's look at that later.

> **Note:** Because of the naming (and experience), I can infer that we are working
> [with the visitor pattern](https://www.dofactory.com/javascript/design-patterns/visitor).
> This is an powerful pattern that is commonly used to analyze and mutate node-based data structures.
> It is a really good pattern to have up your sleeve!

Thinking back at the function call: `visit(tree, "element", visitor)`
we can see that the `test` is in fact a string,
and that it is probably used to filter out which types of nodes that should will be visited.

But I also know from the type signature that it can probably be something else
and that `Test<V>` is likely a [union type](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types),
otherwise it would have probably just been defined as `string`.

Taking a look at it, we can tell that it can be one of these things:

```ts
type Test<T extends Node> =
  | TestType<T>
  | TestObject<T>
  | TestFunction<T>
  | null
  | undefined;
```

Notice that `string` is _not_ one of these types,
and digging deeper into this type definition reveals this:

```ts
type TestType<T extends Node> = T["type"];
```

This very simply means that `TestType<T>` is whatever type that the type property of the `Node` of type `T` is&mdash;easy, right?

OK, sorry, this is super convoluted! As an example, it means that if you create a new type of `Node` called `FooNode`,
and you define a property for it called `type` as a `number`, then `TestType<FooNode>` will resolve to `number`.

So, maybe `TestType` is not the _greatest name_ here, maybe something like `NodeTypeType` &hellip;
yeah maybe this isn't too great either&mdash;naming things is one of the two hard things in software development.

But I digress&mdash;let's go back to the visit function.

So, we now know that it accepts _some type of node_, but _what type of node_ do we need to use here?

This requires a little bit of detective work,
but we can leverage the fact that we know that we're testing for `"element"`,
and that we are working with HTML nodes (this is a rehype plugin which augments HTML syntax trees).

With this in mind, we can probably infer that we are probably working with HTML elements.
The question is, where do we find where this interface is defined?
Looking at the imports, I can see that we are using some utilities such as `hast-util-to-string`.

Having a quick glance at the type definitions for this library, we can find this:

```ts
export type Element = import("hast").Element;
```

So now we know that these types can be imported from `hast` directly!
